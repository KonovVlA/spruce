/**
 * Служебный функционал для работы с коллекциями.
 * @class
 */
export declare class CollectionUtils {
    constructor();
    /**
     * Производит глубокое клонирование данных с преобразованием к типам внутреннего представления интерпретатора для
     * безопасного использования при расчетах.
     * <p>
     * В зависимости от типа объекта выполняется следующее:
     * <p>
     * для экземпляров {@link Collection} (массивов) производится копирование всех данных в новый {@link ArrayList}
     * (массив) с рекурсивным вызовом для них этой же функции;
     * <p>
     * для экземпляров {@link Boolean}, {@link String}, а также проходящих проверку {@link
     * NumberUtils#isBigDecimal(Object)}, производится перенос значения без клонирования;
     * <p>
     * для экземпляров, проходящих проверку {@link #isLikeDate(Object)}, устанавливается значение, полученное
     * выполнением {@link #toDate(Object)};
     * <p>
     * для экземпляров {@link Number} производится порождение соответствующего экземпляра {@link BigDecimal};
     * <p>
     * для экземпляров {@link Map} производится копирование всех пар ключ-значение в новый {@link HashMap} с рекурсивным
     * вызовом для значений этой же функции;
     * <p>
     * для экземпляров, проходящих проверку {@link #isLikeMap(Object)}, устанавливается значение, полученное выполнением
     * {@link #toMap(Object)}.
     *
     * @param {*} source исходный объект.
     *
     * @return {*} объект-клон.
     *
     * @throws ComputingException в случае ошибки преобразования.
     */
    static deepCloneWithTypeConversion(source: any): any;
    /**
     * Извлекает элемент из ассоциативного массива.
     * <p>
     * Функция добавлена, т.к. соответствующий функционал JSweet неправильно обрабатывает null-подобные элементы ({@code
     * false}, {@code 0}).
     *
     * @param {*} map ассоциативный массив.
     * @param {string} key ключ.
     * @param <T> тип значения.
     *
     * @return {*} элемент ассоциативного массива по заданному ключу.
     */
    static get<T>(map: any, key: string): T;
    /**
     * Добавляет элементы в коллекцию.
     * <p>
     * Функция добавлена для реализации отсутствующего функционала JSweet.
     *
     * @param {*[]} collection коллекция.
     * @param {T[]} elements   добавляемые элементы.
     * @param <T>        тип элемента коллекции.
     * @return {*[]}
     */
    static addAll<T>(collection: Array<T>, ...elements: T[]): Array<T>;
    /**
     * Проверяет, что объект может быть использован в интерпретаторе как дата (является экземпляром {@link Date}, {@link
     * Calendar}, {@link XMLGregorianCalendar}).
     *
     * @param {*} value значение для проверки.
     *
     * @return {boolean} {@code true} если объект может использоваться интерпретатором как дата, {@code false} иначе.
     * @private
     */
    static isLikeDate(value: any): boolean;
    /**
     * В Java проверяет, что объект должен быть специальным образом преобразован в Map полей-значений (для этого
     * достаточно проверить, что он не равен {@code null}). В TypeScript/JavaScript всегда возвращает {@code false},
     * т.к. прямая проверка {@code instanceof Object} в вызывающей функции выполняется раньше, а в ее блоке выполняется
     * универсальное преобразование в Object.
     *
     * @param {*} value значение для проверки.
     * @param <T>   тип значения.
     *
     * @return {boolean} {@code true} если объект, должен специальным образом преобразован в Map, {@code false} иначе.
     * @private
     */
    static isLikeMap<T>(value: T): boolean;
    /**
     * Возвращает дату во внутреннем представлении интерпретатора для совместимых типов (совместимость можно
     * предварительно проконтролировать вызовом {@link #isLikeDate(Object)}).
     *
     * @param {*} value значение.
     *
     * @return {Date} дата во внутреннем представлении интерпретатора или {@code null} для несовместимых с преобразованием
     * значений.
     * @private
     */
    static toDate(value: any): Date;
    /**
     * В Java конвертирует объект в Map (объект должен удовлетворять требованиям JavaBeans). В TypeScript/JavaScript
     * всегда возвращает {@code null}, т.к. прямая проверка {@code instanceof Object} в вызывающей функции выполняется
     * раньше, а в ее блоке выполняется универсальное преобразование в Object.
     *
     * @param {*} value значение для преобразования.
     *
     * @return {*} в Java возвращает конвертированный в Map объект, в TypeScript/JavaScript возвращает {@code null}.
     *
     * @throws ComputingException в случае ошибки преобразования.
     * @private
     */
    static toMap(value: any): any;
}
